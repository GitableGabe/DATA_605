training.samples <- df_1k_norm_svm$Total.Revenue %>%
createDataPartition(p = 0.8, list = FALSE)
train_df  <- df_1k_norm_svm[training.samples, ]
test_df <- df_1k_norm_svm[-training.samples, ]
svm_model<-svm(formula = Total.Revenue ~ ., data = train_df,
type = 'eps-regression')
print(svm_model)
library(Amelia)
library(car)
library(caret)
library(corrplot)
library(Cubist)
library(DataExplorer)
library(dplyr)
library(e1071)
library(earth)
library(forcats)
library(forecast)
library(fpp3)
library(gbm)
library(ggplot2)
library(ggforce)
library(gridExtra)
library(kableExtra)
library(MASS)
library(Metrics)
library(mice)
library(mlbench)
library(party)
library(psych)
library(pROC)
library(randomForest)
library(RANN)
library(RColorBrewer)
library(readr)
library(readxl)
library(rpart)
library(rpart.plot)
library(stringr)
library(summarytools)
library(tidyr)
library(tidymodels)
library(VIM)
library(earth)
library(randomForest)
url_git_2018<-"https://raw.githubusercontent.com/GitableGabe/Data624_Data/main/Underlying%20Cause%20of%20Death%2C%202018%2C%20Single%20Race.txt"
url_git_2019<-"https://raw.githubusercontent.com/GitableGabe/Data624_Data/main/Underlying%20Cause%20of%20Death%2C%202019%2C%20Single%20Race.txt"
url_git_2020<-"https://raw.githubusercontent.com/GitableGabe/Data624_Data/main/Underlying%20Cause%20of%20Death%2C%202020%2C%20Single%20Race.txt"
url_git_2021<-"https://raw.githubusercontent.com/GitableGabe/Data624_Data/main/Underlying%20Cause%20of%20Death%2C%202021%2C%20Single%20Race.txt"
url_git_2022<-"https://raw.githubusercontent.com/GitableGabe/Data624_Data/main/Underlying%20Cause%20of%20Death%2C%202022%2C%20Single%20Race.txt"
cdc_ucd_df_2018 <- as_tibble(read_tsv(url_git_2018,
show_col_types = FALSE)
)%>%
dplyr::select(-1)%>%
rename(Race = `Single Race 6`,
`Race Code` = `Single Race 6 Code`)
cdc_ucd_df_2019 <- as_tibble(read_tsv(url_git_2019,
show_col_types = FALSE)
)%>%
dplyr::select(-1)%>%
rename(Race = `Single Race 6`,
`Race Code` = `Single Race 6 Code`)
cdc_ucd_df_2020 <- as_tibble(read_tsv(url_git_2020,
show_col_types = FALSE)
)%>%
dplyr::select(-1)%>%
rename(Race = `Single Race 6`,
`Race Code` = `Single Race 6 Code`)
cdc_ucd_df_2021 <- as_tibble(read_tsv(url_git_2021,
show_col_types = FALSE)
)%>%
dplyr::select(-1)%>%
rename(Race = `Single Race 6`,
`Race Code` = `Single Race 6 Code`)
cdc_ucd_df_2022 <- as_tibble(read_tsv(url_git_2022,
show_col_types = FALSE)
)%>%
dplyr::select(-1)%>%
rename(Race = `Single Race 6`,
`Race Code` = `Single Race 6 Code`)
cdc_ucd_df <- bind_rows(cdc_ucd_df_2018,
cdc_ucd_df_2020,
cdc_ucd_df_2021,
cdc_ucd_df_2022)
rm(list = ls()[!grepl("cdc_ucd_df$", ls())])
glimpse(cdc_ucd_df)
describe(cdc_ucd_df)
summary(cdc_ucd_df)
apply(cdc_ucd_df, 2, function(x) sum(is.na(x)))
data.frame(missing = colSums(is.na(cdc_ucd_df))) |>
filter(missing == 0) |>
rownames()
plot_missing(cdc_ucd_df,
missing_only = T,
ggtheme = theme_classic(),
theme_config = list(legend.position = c("right")),
geom_label_args = list("size" = 3, "label.padding" = unit(0.1, "lines")))
VIM::aggr(cdc_ucd_df, numbers=T, sortVars=T, bars = FALSE,
cex.axis = .6)
cdc_ucd_df<-na.omit(cdc_ucd_df)
# kable(cdc_ucd_df$`Cause of death`, format = "html", row.names = TRUE) %>%
#   kable_styling(full_width = FALSE)
DataExplorer::plot_histogram(cdc_ucd_df, nrow = 4L, ncol = 4L, ggtheme = theme_classic())
# Create bar plot for gender distribution
ggplot(cdc_ucd_df, aes(x = Gender, fill = Gender)) +
geom_bar() +
labs(title = "Gender Distribution", x = "Gender", y = "Frequency") +
theme_minimal() +  # Change the theme to minimal
theme(legend.position = "none") +  # Remove legend
scale_fill_manual(values = c("Male" = "skyblue",
"Female" = "pink"))  # Custom fill colors
# Create bar plot for race distribution
ggplot(cdc_ucd_df, aes(x = str_wrap(`Race`, width = 10),
fill = `Race`)) +
geom_bar() +
labs(title = "Race Distribution", x = "Race", y = "Frequency") +
theme_minimal() +  # Change the theme to minimal
theme(legend.position = "none",
axis.text.x = element_text(angle = 45,
hjust = 1)) +  # Remove legend
scale_fill_manual(values = c("Asian" = "lightgreen",
"Black" = "lightblue",
"White" = "lightcoral"))  # Custom fill colors
# Calculate frequency of each cause of death
top_10_ca_freq<- table(cdc_ucd_df$`Cause of death`)
# Select the top 10 causes of death
top_10_ca <- names(sort(top_10_ca_freq, decreasing = TRUE))[1:10]
# Filter data to include only the top 10 causes of death
top_10_ca_data <- subset(cdc_ucd_df, `Cause of death` %in% top_10_ca)
# Create the plot with sorted values
ggplot(top_10_ca_data, aes(x = reorder(str_wrap(`Cause of death`, width = 23), -table(`Cause of death`)[`Cause of death`]), fill = `Cause of death`)) +
geom_bar() +
labs(title = "Top 10 Causes of Death", x = "Cause", y = "Frequency") +
theme_minimal() +  # Change the theme to minimal
theme(legend.position = "none",
axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1)) +   # Rotate x-axis labels by 45 degrees
coord_flip()
# Calculate frequency of each cause of death by race
ca_freq_rc <- table(cdc_ucd_df$Race, cdc_ucd_df$`Cause of death`,
cdc_ucd_df$Gender)
# Convert the frequency table to a data frame
ca_freq_rc_df <- as.data.frame.table(ca_freq_rc)
# Rename columns
names(ca_freq_rc_df) <- c("Race", "Cause","Gender", "Frequency")
# Sort by frequency in descending order
ca_freq_rc_df <-
ca_freq_rc_df[order(ca_freq_rc_df$Frequency,
decreasing = TRUE),]
unique(cdc_ucd_df$Gender)
# Filter to keep only the top 3 causes of death for each race
top_3_causes <- do.call(rbind,
lapply(split(ca_freq_rc_df,
list(ca_freq_rc_df$Race, ca_freq_rc_df$Gender)),
function(x) {
race_gender <- unique(x$Race)[1]
gender <- unique(x$Gender)[1]
head(x[order(-x$Frequency), ], 3)
}))
top_3_causes_m <- subset(top_3_causes, Gender == "Male")
top_3_causes_f <- subset(top_3_causes, Gender == "Female")
top_3_causes_o <- subset(top_3_causes, Gender == "NA")
# Create the plot for males
ggplot(top_3_causes_m, aes(x = Race, y = Frequency, fill = Cause)) +
geom_bar(stat = "identity", position = "dodge") +
labs(title = "Top 3 Causes of Death by Race (Males)", x = "Race", y = "Frequency") +
theme_minimal() +
theme(legend.position = "bottom") +  # Position the legend at the bottom
scale_fill_discrete(labels = function(x) str_wrap(x, width = 10))+
# Manually wrap legend labels
coord_flip()
# Create the plot for females
ggplot(top_3_causes_f, aes(x = Race, y = Frequency, fill = Cause)) +
geom_bar(stat = "identity", position = "dodge") +
labs(title = "Top 3 Causes of Death by Race (Female)", x = "Race", y = "Frequency") +
theme_minimal() +
theme(legend.position = "bottom") +  # Position the legend at the bottom
scale_fill_discrete(labels = function(x) str_wrap(x, width = 10))+
# Manually wrap legend labels
coord_flip()
# Create the plot for females
ggplot(top_3_causes_o, aes(x = Race, y = Frequency, fill = Cause)) +
geom_bar(stat = "identity", position = "dodge") +
labs(title = "Top 3 Causes of Death by Race (Niether Male or Female)", x = "Race", y = "Frequency") +
theme_minimal() +
theme(legend.position = "bottom") +  # Position the legend at the bottom
scale_fill_discrete(labels = function(x) str_wrap(x, width = 10))+
# Manually wrap legend labels
coord_flip()
(unreliable_count <- sum(cdc_ucd_df$`Crude Rate` == "Unreliable", na.rm = TRUE))
rm(list = ls()[!grepl("^cdc_ucd", ls())])
cdc_model<-cdc_ucd_df%>%
dplyr::select(-c(`Year Code`,`County Code`, `Race Code`,`Gender Code`,`Cause of death Code`, `Crude Rate`))
cdc_model <- cdc_model %>%
mutate(
County = as.factor(`County`),
Gender = as.factor(Gender),
Race = as.factor(str_trim(Race)),
`Cause of death` = as.factor(`Cause of death`),
Year = as.Date(paste0(Year, "-01-01"))  # Convert Year to Date with January 1st as the date
) %>%
predict(preProcess(., method = c("center", "scale")), .)
# Set seed for reproducibility
set.seed(1234)
#
# # Process the data: trim whitespace and convert to factors
# cdc_model <- cdc_model %>%
#   mutate(
#     County = as.factor(str_trim(County)),
#     Gender = as.factor(str_trim(Gender)),
#     Race = as.factor(str_trim(Race)),
#     `Cause of death` = as.factor(str_trim(`Cause of death`))
#   )
# Remove rows with NA values
cdc_model <- na.omit(cdc_model)
# Split the data
training.samples <- cdc_model$Deaths %>%
createDataPartition(p = 0.8, list = FALSE)
train_df <- cdc_model[training.samples, ]
test_df <- cdc_model[-training.samples, ]
# Identify and remove constant variables in the training set
constant_vars <- sapply(train_df, function(x) length(unique(x)) == 1)
train_df <- train_df[, !constant_vars]
# Ensure the same columns are removed from the test set
test_df <- test_df[, colnames(train_df)]
# Fit the SVM model
svm_model <- svm(formula = Deaths ~ ., data = train_df, type = 'eps-regression')
# Print the SVM model
print(svm_model)
# Predict using the SVM model
predictions_SVM <- predict(svm_model, newdata = test_df)
# Combine predictions with the test dataset
predictions_SVM <- data.frame(Predicted = predictions_SVM, test_df)
# Print predictions
# print(predictions_SVM)
predictions_SVM <- predict(svm_model, newdata = test_df) %>%
bind_cols(test_df)
predictions_SVM$...1 <- as.numeric(predictions_SVM$...1)
MAE <- MAE(predictions_SVM$Deaths, predictions_SVM$...1)
RMSE <- RMSE(predictions_SVM$Deaths, predictions_SVM$...1)
R2 <- R2(predictions_SVM$Deaths, predictions_SVM$...1)
# Create a data frame to store the results
a_svm <- data.frame(Model = "SVM",
MAE = MAE,
RMSE = RMSE,
R2 = R2)
# Print the results
print(a_svm)
# Calculate frequency of each cause of death
top_10_ca_freq<- table(cdc_model$`Cause of death`)
# Select the top 10 causes of death
top_10_ca <- names(sort(top_10_ca_freq, decreasing = TRUE))[1:10]
# Filter data to include only the top 10 causes of death
top_10_ca_data <- subset(cdc_model, `Cause of death` %in% top_10_ca)
top_10_ca_data<-top_10_ca_data%>%
dplyr::select(-Population)
set.seed(1234)
cdc_rf_model <- top_10_ca_data
#split
training_cdc_samples <- cdc_rf_model$Deaths %>%
createDataPartition(p = 0.8, list = FALSE)
train_cdc  <- cdc_rf_model[training_cdc_samples, ]
test_cdc <- cdc_rf_model[-training_cdc_samples, ]
#train using rpart, cp- complexity, smaller # = more complexity,
#method- anova is for regression
tree_cdc <- rpart(Deaths ~., data = train_cdc, cp = 0.004,  method = 'anova')
#visualize
# rpart.plot(tree_cdc)
# print(tree_1k1)
# Open a PNG graphics device
png("tree_cdc.png", width = 1000, height = 600, res=300)  # Adjust width and height as needed
# Plot the tree using rpart.plot
rpart.plot(tree_cdc)
# Close the graphics device and save the plot as "tree_cdc.png"
dev.off()
# Open a PNG graphics device with high resolution
png("tree_cdc_hd.png", width = 2040, height = 1200, res = 300)  # 300 DPI
# Plot the tree using rpart.plot with custom text settings
rpart.plot(tree_cdc, extra = 101, type = 3, under = TRUE,  faclen = 0, varlen = 0, snip = TRUE,
cex = .3, # Increase font size
branch.lty = 1, branch.lwd = .5, # Set branch line type and width
main = "Decision Tree for CDC Data", # Add a main title
split.cex = .5, split.box.col = "lightblue", split.border.col = "blue") # Customize split nodes
# Close the graphics device and save the plot as "tree_cdc_hd.png"
dev.off()
predictions_tree <- predict(tree_cdc, newdata = test_cdc) %>%
bind_cols(test_cdc )
predictions_tree$...1 <- as.numeric(predictions_tree$...1)
decision_tree_model <- data.frame(Model = "Decision Tree 1",
MAE = ModelMetrics::mae(predictions_tree$Deaths, predictions_tree$...1),
#rmse Root Mean Squared Error
RMSE = ModelMetrics::rmse(predictions_tree$Deaths, predictions_tree$...1),
#r squared
R2 = caret::R2(predictions_tree$Deaths, predictions_tree$...1)
)
decision_tree_model
write.csv(my_dataframe, file = "predictions_SVM.csv", row.names = TRUE)
write.csv(predictions_SVM, file = "predictions_SVM.csv", row.names = TRUE)
write.csv(predictions_tree, file = "predictions_tree.csv", row.names = TRUE)
install.packages(c("Amelia", "backports", "brio", "broom", "bslib", "cachem", "callr", "checkmate", "cli", "clock", "colorspace", "corrplot", "cpp11", "crayon", "Cubist", "curl", "data.table", "DBI", "dbplyr", "dials", "digest", "evaluate", "fable", "fabletools", "farver", "fastmap", "feasts", "forecast", "fpp3", "fs", "future", "future.apply", "gbm", "ggdist", "ggfortify", "ggplot2", "gtable", "hardhat", "highr", "htmltools", "infer", "ipred", "kernlab", "knitr", "labelled", "lhs", "lme4", "magick", "matrixStats", "minqa", "mlbench", "modeldata", "multcomp", "munsell", "mvtnorm", "nloptr", "openssl", "openxlsx", "ordinal", "parallelly", "parsnip", "party", "pbkrtest", "pkgload", "plotmo", "pls", "polyclip", "processx", "prodlim", "ps", "psych", "quantreg", "ragg", "RANN", "Rcpp", "RcppArmadillo", "RcppEigen", "recipes", "renv", "reprex", "rlang", "rmarkdown", "robustbase", "rsample", "rsconnect", "rstudioapi", "sass", "sp", "SparseM", "stringi", "systemfonts", "testthat", "textshaping", "tidymodels", "tidyselect", "tinytex", "tseries", "tsibble", "tune", "ucminf", "urca", "uuid", "waldo", "withr", "workflowsets", "x13binary", "xfun", "xts", "yaml", "yardstick"))
#Define matrix A
A<-
matrix(c(0,4,-1,1,
-2,6,-1,-1,
-2,8,-1,-1,
-1,8,-3,1),nrow=4, byrow=TRUE)
print(A)
# Calculate eigenvalues and eigenvectors
eigen_result<-eigen(A)
# Display eigenvalues
paste("Eigenvalues:", paste(eigen_result$values, collapse = ", "))
# Display eigenvectors
paste("Eigenvectors:", paste(eigen_result$vectors, collapse = ", "))
#Define matrix A
A<-
matrix(c(0,4,-1,1,
-2,6,-1,-1,
-2,8,-1,-1,
-1,8,-3,1),nrow=4, byrow=TRUE)
print(A)
#Define matrix A
A<-
matrix(c(0,4,-1,1,
-2,6,-1,-1,
-2,8,-1,-1,
-1,8,-3,1),nrow=4, byrow=TRUE)
print(A)
#Define matrix A
A<-
matrix(c(0,4,-1,1,
-2,6,-1,-1,
-2,8,-1,-1,
-1,8,-3,1),nrow=4, byrow=TRUE)
print(A)
#Define matrix A
A<-
matrix(c(0,4,-1,1,
-2,6,-1,-1,
-2,8,-1,-1,
-1,8,-3,1),nrow=4, byrow=TRUE)
print(A)
#Define matrix A
A<-
matrix(c(0,4,-1,1,
-2,6,-1,-1,
-2,8,-1,-1,
-1,8,-3,1),nrow=4, byrow=TRUE)
print(A)
# Calculate eigenvalues and eigenvectors
eigen_result<-eigen(A)
# Display eigenvalues
paste("Eigenvalues:", paste(eigen_result$values, collapse = ", "))
# Display eigenvectors
paste("Eigenvectors:", paste(eigen_result$vectors, collapse = ", "))
setwd("C:/Users/xusef/Documents/GitableGabe/DATA_605")
setwd("C:/Users/xusef/Documents/GitableGabe/DATA_698")
setwd("C:/Users/xusef/Documents/GitableGabe/DATA_605")
# Add matrices A and B
C <- A + B
A <- matrix(seq(from = 1, to = 6), nrow = 2, byrow = TRUE)
B <- matrix(seq(from = 12, to = 7), nrow = 2)
A
B
A <- matrix(seq(from = 1, to = 6), nrow = 2, byrow = TRUE)
B <- matrix(seq(from = 12, to = 7), nrow = 2)
A
# Add matrices A and B
C <- A + B
print(C)
I
print(I)
I <- base::diag(3)
print(I)
library("gganimate")
library("ggplot2")
library("gridExtra")
library("jpeg")
library("png")
library("reshape2")
install.packages("ggplot2")
library("gganimate")
library("ggplot2")
library("gridExtra")
library("jpeg")
library("png")
library("reshape2")
gray <- readPNG("GrayScaleIMG.png")
gray_matrix <- as.matrix(gray)
gray_svd <- svd(gray_matrix)
gray_U<- gray_svd$u
gray_Sigma<- gray_svd$d
gray_Vt<- gray_svd$vt
gray_reconstruct <- function(k){
gray_U_k <- gray_U[,1:k]
gray_Sigma_k <- diag(gray_Sigma[1:k])
gray_Vt_k <- gray_Vt[,1:k]
gray_img_reconstructed <- gray_U_k %% gray_Sigma_k %% t(gray_Vt_k)
return(gray_img_reconstructed)
}
plot_image <- function(gray_matrix, title) {
ggplot( melt(gray_matrix), aes(Var1, Var2, fill = value)) +
geom_raster() +
scale_fill_gradient(low = "black", high = "white") +
coord_fixed() +
theme_void() +
ggtitle(title) +
theme(plot.title = element_text(hjust = 0.5))
}
# Add to plots various k values
k_values <- c(5, 20, 50)
# to store multiple plots
plots <- list()
# Plot the original image and store it to list
gray_plot <- plot_image(gray_matrix, "Gray Scale Image")
plots[[1]] <- gray_plot
# Plot compressed versions for each k
for (i in 1:length(k_values)) {
k <- k_values[i]
gray_compressed <- gray_reconstruct(k)
plot_title <- paste("Compressed Image (k =", k, ")")
plots[[i + 1]] <- plot_image(gray_compressed, plot_title)
}
# Step 1: Read and convert a grayscale image into a matrix
img <- readPNG("GrayScaleIMG.png")  # Specify the image path
img_matrix <- as.matrix(img)
# Step 2: Perform Singular Value Decomposition (SVD)
svd_result <- svd(img_matrix)
# Extract U, Sigma, and V^T matrices
U <- svd_result$u
Sigma <- svd_result$d  # This is a vector of singular values
Vt <- svd_result$v
# Step 3: Define the function to reconstruct the image using only the top k singular values
reconstruct_image <- function(k) {
# Ensure k does not exceed the number of singular values
max_k <- length(Sigma)
k <- min(k, max_k)
# Reconstruct the image using the top k singular values
U_k <- U[, 1:k]        # m x k
Sigma_k <- diag(Sigma[1:k], k, k)  # k x k
Vt_k <- Vt[, 1:k]      # n x k
# Multiply U_k, Sigma_k, and Vt_k^T
img_reconstructed <- U_k %*% Sigma_k %*% t(Vt_k)
# Return the reconstructed image
return(img_reconstructed)
}
# Step 4: Plot the original image and compressed versions for different k values
plot_image <- function(img_matrix, title) {
# Create row and column identifiers for the matrix
img_df <- as.data.frame(img_matrix)
img_df$row <- 1:nrow(img_df)
img_melted <- melt(img_df, id.vars = "row", variable.name = "col")
# Create a ggplot object to plot the matrix as a raster
ggplot(img_melted, aes(x = as.numeric(col), y = row, fill = value)) +
geom_raster() +
scale_fill_gradient(low = "black", high = "white") +
coord_fixed() +
theme_void() +
ggtitle(title) +
theme(plot.title = element_text(hjust = 0.5))
}
# Prepare plots for various k values
k_values <- c(5, 20, 50)  # Values of k for compression
plots <- list()
# Plot the original image
original_plot <- plot_image(img_matrix, "Original Image")
plots[[1]] <- original_plot
# Plot compressed versions for each k
for (i in 1:length(k_values)) {
k <- k_values[i]
compressed_img <- reconstruct_image(k)
plot_title <- paste("Compressed Image (k =", k, ")")
plots[[i + 1]] <- plot_image(compressed_img, plot_title)
}
# Step 5: Visualize all plots
# Use do.call with the list of plots and specify additional arguments separately
do.call(grid.arrange, c(plots, list(ncol = 2)))
plot_image <- function(gray_matrix, title) {
ggplot( melt(gray_matrix), aes(Var1, Var2, fill = value)) +
geom_raster() +
scale_fill_gradient(low = "black", high = "white") +
coord_fixed() +
theme_void() +
ggtitle(title) +
theme(plot.title = element_text(hjust = 0.5))
}
# Add to plots various k values
k_values <- c(5, 20, 50)
# to store multiple plots
plots <- list()
# Plot the original image and store it to list
gray_plot <- plot_image(gray_matrix, "Gray Scale Image")
plots[[1]] <- gray_plot
# Plot compressed versions for each k
for (i in 1:length(k_values)) {
k <- k_values[i]
gray_compressed <- gray_reconstruct(k)
plot_title <- paste("Compressed Image (k =", k, ")")
plots[[i + 1]] <- plot_image(gray_compressed, plot_title)
}
k_example <- 10
compressed_img <- reconstruct_image(k_example)
# Convert the matrix to a data frame for ggplot
img_df <- as.data.frame(compressed_img)
img_df$row <- 1:nrow(img_df)
img_melted <- melt(img_df, id.vars = "row", variable.name = "col")
# Plot the compressed image
ggplot(img_melted, aes(x = as.numeric(col), y = row, fill = value)) +
geom_raster() +
scale_fill_gradient(low = "black", high = "white") +
coord_fixed() +
theme_void() +
ggtitle(paste("Compressed Image (k =", k_example, ")")) +
theme(plot.title = element_text(hjust = 0.5))
