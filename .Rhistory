P_a <- matrix(c(0.5, 0.5,
0.5, 0.5),
nrow = 2, byrow = TRUE)
P_b <- matrix(c(0.5, 0.5,
1, 1),
nrow = 2, byrow = TRUE)
P_c <- matrix(c(1/3, 0, 2/3,
0, 1, 0,
0, 1/5, 2/5),
nrow = 3, byrow = TRUE)
# Function to check if a matrix is regular
is_regular <- function(P, max_iter = 10) {
# Start with the initial matrix
P_k <- P
# Iterate to compute P^k
for (k in 1:max_iter) {
# Check if all entries are positive
if (all(P_k > 0)) {
return(TRUE)  # The matrix is regular
}
# Multiply the matrix by itself to get the next power
P_k <- P_k %*% P
}
# If we reach max_iter without finding all positive entries, it's not regular
return(FALSE)
}
# Test if the matrix is regular
is_regular(P_a)
# Define the matrix P
P_a <- matrix(c(0.5, 0.5,
0.5, 0.5),
nrow = 2, byrow = TRUE)
P_b <- matrix(c(0.5, 0.5,
1, 1),
nrow = 2, byrow = TRUE)
P_c <- matrix(c(1/3, 0, 2/3,
0, 1, 0,
0, 1/5, 2/5),
nrow = 3, byrow = TRUE)
is_regular <- function(P, max_iter = 10) {
# Start with the initial matrix
P_k <- P
for (k in 1:max_iter) {
cat("P^", k, ":\n")
print(P_k)
# Check if all entries are positive
if (all(P_k > 0) && !all(P_k == P)) {
return(TRUE)  # The matrix is regular if all entries are positive and P_k != P
}
# Multiply the matrix by itself to get the next power
P_k <- P_k %*% P
}
# If we reach max_iter without finding all positive entries, it's not regular
return(FALSE)
}
# Test if the matrix is regular
is_regular(P_b)
# Test if the matrix is regular
is_regular(P_c)
# Test if the matrix is regular
is_regular(P_a)
# Define the matrix P
P_a <- matrix(c(0.5, 0.5,
0.5, 0.5),
nrow = 2, byrow = TRUE)
P_b <- matrix(c(0.5, 0.5,
1, 1),
nrow = 2, byrow = TRUE)
P_c <- matrix(c(1/3, 0, 2/3,
0, 1, 0,
0, 1/5, 2/5),
nrow = 3, byrow = TRUE)
is_regular <- function(P, max_iter = 10) {
P_k <- P
for (k in 1:max_iter) {
cat("P^", k, ":\n")
print(P_k)
# Check if all entries are positive and that it is not the same as the previous matrix
if (all(P_k > 0) && !all(P_k == P)) {
return(TRUE)  # The matrix is regular
}
# Multiply the matrix by itself to get the next power
P_k <- P_k %*% P
}
return(FALSE)
}
# Test if the matrix is regular
is_regular(P_a)
# Test if the matrix is regular
is_regular(P_b)
# Test if the matrix is regular
if (is_valid_transition_matrix(P_a)) {
print(is_regular(P_a))
} else {
print("The matrix is not a valid transition matrix.")
}
# Define the matrix P
P_a <- matrix(c(0.5, 0.5,
0.5, 0.5),
nrow = 2, byrow = TRUE)
P_b <- matrix(c(0.5, 0.5,
1, 1),
nrow = 2, byrow = TRUE)
P_c <- matrix(c(1/3, 0, 2/3,
0, 1, 0,
0, 1/5, 2/5),
nrow = 3, byrow = TRUE)
# Function to check if a matrix is valid
is_valid_transition_matrix <- function(P) {
# Check if all entries are non-negative and sum to 1 for each row
if (any(P < 0) || any(rowSums(P) != 1)) {
return(FALSE)
}
return(TRUE)
}
is_regular <- function(P, max_iter = 10) {
P_k <- P
for (k in 1:max_iter) {
cat("P^", k, ":\n")
print(P_k)
# Check if all entries are positive and that it is not the same as the previous matrix
if (all(P_k > 0) && !all(P_k == P)) {
return(TRUE)  # The matrix is regular
}
# Multiply the matrix by itself to get the next power
P_k <- P_k %*% P
}
return(FALSE)
}
# Test if the matrix is regular
if (is_valid_transition_matrix(P_a)) {
print(is_regular(P_a))
} else {
print("The matrix is not a valid transition matrix.")
}
# Test if the matrix is regular
# Test if the matrix is regular
if (is_valid_transition_matrix(P_b)) {
print(is_regular(P_b))
} else {
print("The matrix is not a valid transition matrix.")
}
# Test if the matrix is regular
if (is_valid_transition_matrix(P_c)) {
print(is_regular(P_c))
} else {
print("The matrix is not a valid transition matrix.")
}
# Define the matrix P
P_a <- matrix(c(0.5, 0.5,
0.5, 0.5),
nrow = 2, byrow = TRUE)
P_b <- matrix(c(0.5, 0.5,
1, 1),
nrow = 2, byrow = TRUE)
P_c <- matrix(c(1/3, 0, 2/3,
0, 1, 0,
0, 1/5, 4/5),
nrow = 3, byrow = TRUE)
# Function to check if a matrix is valid
is_valid_transition_matrix <- function(P) {
# Check if all entries are non-negative and sum to 1 for each row
if (any(P < 0) || any(rowSums(P) != 1)) {
return(FALSE)
}
return(TRUE)
}
is_regular <- function(P, max_iter = 10) {
P_k <- P
for (k in 1:max_iter) {
cat("P^", k, ":\n")
print(P_k)
# Check if all entries are positive and that it is not the same as the previous matrix
if (all(P_k > 0) && !all(P_k == P)) {
return(TRUE)  # The matrix is regular
}
# Multiply the matrix by itself to get the next power
P_k <- P_k %*% P
}
return(FALSE)
}
# Test if the matrix is regular
if (is_valid_transition_matrix(P_a)) {
print(is_regular(P_a))
} else {
print("The matrix is not a valid transition matrix.")
}
# Test if the matrix is regular
# Test if the matrix is regular
if (is_valid_transition_matrix(P_b)) {
print(is_regular(P_b))
} else {
print("The matrix is not a valid transition matrix.")
}
# Test if the matrix is regular
# Test if the matrix is regular
if (is_valid_transition_matrix(P_b)) {
print(is_regular(P_b))
} else {
print("The matrix is not a valid transition matrix.")
}
# Test if the matrix is regular
if (is_valid_transition_matrix(P_c)) {
print(is_regular(P_c))
} else {
print("The matrix is not a valid transition matrix.")
}
# Test if the matrix is regular
if (is_valid_transition_matrix(P_d)) {
print(is_regular(P_d))
} else {
print("The matrix is not a valid transition matrix.")
}
# Define the matrix P
P_a <- matrix(c(0.5, 0.5,
0.5, 0.5),
nrow = 2, byrow = TRUE)
P_b <- matrix(c(0.5, 0.5,
1, 1),
nrow = 2, byrow = TRUE)
P_c <- matrix(c(1/3, 0, 2/3,
0, 1, 0,
0, 1/5, 4/5),
nrow = 3, byrow = TRUE)
P_d <- matrix(c(0, 1,
1, 0),
nrow = 2, byrow = TRUE)
# Function to check if a matrix is valid
is_valid_transition_matrix <- function(P) {
# Check if all entries are non-negative and sum to 1 for each row
if (any(P < 0) || any(rowSums(P) != 1)) {
return(FALSE)
}
return(TRUE)
}
is_regular <- function(P, max_iter = 10) {
P_k <- P
for (k in 1:max_iter) {
cat("P^", k, ":\n")
print(P_k)
# Check if all entries are positive and that it is not the same as the previous matrix
if (all(P_k > 0) && !all(P_k == P)) {
return(TRUE)  # The matrix is regular
}
# Multiply the matrix by itself to get the next power
P_k <- P_k %*% P
}
return(FALSE)
}
# Test if the matrix is regular
if (is_valid_transition_matrix(P_a)) {
print(is_regular(P_a))
} else {
print("The matrix is not a valid transition matrix.")
}
# Test if the matrix is regular
# Test if the matrix is regular
if (is_valid_transition_matrix(P_b)) {
print(is_regular(P_b))
} else {
print("The matrix is not a valid transition matrix.")
}
# Test if the matrix is regular
if (is_valid_transition_matrix(P_c)) {
print(is_regular(P_c))
} else {
print("The matrix is not a valid transition matrix.")
}
# Test if the matrix is regular
if (is_valid_transition_matrix(P_d)) {
print(is_regular(P_d))
} else {
print("The matrix is not a valid transition matrix.")
}
# Test if the matrix is regular
if (is_valid_transition_matrix(P_e)) {
print(is_regular(P_e))
} else {
print("The matrix is not a valid transition matrix.")
}
# Define the matrix P
P_a <- matrix(c(0.5, 0.5,
0.5, 0.5),
nrow = 2, byrow = TRUE)
P_b <- matrix(c(0.5, 0.5,
1, 1),
nrow = 2, byrow = TRUE)
P_c <- matrix(c(1/3, 0, 2/3,
0, 1, 0,
0, 1/5, 4/5),
nrow = 3, byrow = TRUE)
P_d <- matrix(c(0, 1,
1, 0),
nrow = 2, byrow = TRUE)
P_e <- matrix(c(1/2, 1/2, 0,
0, 1/2, 1/2,
1/3, 1/3, 1/3),
nrow = 3, byrow = TRUE)
# Function to check if a matrix is valid
is_valid_transition_matrix <- function(P) {
# Check if all entries are non-negative and sum to 1 for each row
if (any(P < 0) || any(rowSums(P) != 1)) {
return(FALSE)
}
return(TRUE)
}
is_regular <- function(P, max_iter = 10) {
P_k <- P
for (k in 1:max_iter) {
cat("P^", k, ":\n")
print(P_k)
# Check if all entries are positive and that it is not the same as the previous matrix
if (all(P_k > 0) && !all(P_k == P)) {
return(TRUE)  # The matrix is regular
}
# Multiply the matrix by itself to get the next power
P_k <- P_k %*% P
}
return(FALSE)
}
# Test if the matrix is regular
if (is_valid_transition_matrix(P_a)) {
print(is_regular(P_a))
} else {
print("The matrix is not a valid transition matrix.")
}
# Test if the matrix is regular
# Test if the matrix is regular
if (is_valid_transition_matrix(P_b)) {
print(is_regular(P_b))
} else {
print("The matrix is not a valid transition matrix.")
}
# Test if the matrix is regular
if (is_valid_transition_matrix(P_c)) {
print(is_regular(P_c))
} else {
print("The matrix is not a valid transition matrix.")
}
# Test if the matrix is regular
if (is_valid_transition_matrix(P_d)) {
print(is_regular(P_d))
} else {
print("The matrix is not a valid transition matrix.")
}
# Test if the matrix is regular
if (is_valid_transition_matrix(P_e)) {
print(is_regular(P_e))
} else {
print("The matrix is not a valid transition matrix.")
}
# Initialize the expected steps for each state with 0 for the absorbing state
E <- c(0, 0, 0, 0, 0)
E[5] <- 0  # Absorbing state
# Iteratively calculate from E(4) up to E(1)
E[4] <- 1 + E[5]            # E(4) only goes to state 5
E[3] <- 1 + 0.5 * (E[4] + E[5])  # E(3) goes to states 4 or 5
E[2] <- 1 + (1/3) * (E[3] + E[4] + E[5])  # E(2) goes to states 3, 4, or 5
E[1] <- 1 + (1/4) * (E[2] + E[3] + E[4] + E[5])  # E(1) goes to states 2, 3, 4, or 5
# Display results
names(E) <- paste0("E(", 1:5, ")")
E
sensitivity <- 0.90                    # P(Positive | Default)
specificity <- 0.95                    # P(Negative | No Default)
prevalence <- 0.02                     # P(Default)
false_positive_rate<- 1-specificity    # False positive rate
p_positive<- (sensitivity*prevalence)+
(false_positive_rate*(1-prevalence)) # P(Positive)
p_default_given_positive<-(sensitivity * prevalence)/p_positive
p_default_given_positive
cost_per_test<- 500
cost_default<- 200000
total_borrowers<- 10000
expected_borrowers<-10000*prevalence
expected_default_cost<-expected_borrowers*cost_default
cost_per_test<- 500
cost_default<- 200000
total_borrowers<- 10000
expected_borrowers<-10000*prevalence
expected_default_cost<-expected_borrowers*cost_default
expected_borrowers
cost_per_test<- 500
cost_default<- 200000
total_borrowers<- 10000
expected_borrowers<-10000*prevalence
expected_default_cost<-expected_borrowers*cost_default
expected_default_cost
print(expected_default_cost)
cost_per_test<- 500
cost_default<- 200000
total_borrowers<- 10000
expected_borrowers<-10000*prevalence
expected_default_cost<-expected_borrowers*cost_default
format(expected_default_cost, scientific = FALSE)
expected_borrowers+expected_default_cost
cost_per_test<- 500
cost_default<- 200000
total_borrowers<- 10000
expected_loss<-p_default_given_positive*cost_default
expected_borrowers<-10000*prevalence
expected_default_cost<-expected_borrowers*cost_default
testing_cost<-cost_per_test*total_borrowers
expected_default_cost+testing_cost
cost_per_test<- 500
cost_default<- 200000
total_borrowers<- 10000
expected_loss<-p_default_given_positive*cost_default
expected_borrowers<-10000*prevalence
expected_default_cost<-expected_borrowers*cost_default
testing_cost<-cost_per_test*total_borrowers
format(expected_default_cost+testing_cost, scientific = FALSE)
data <- read.csv("LifeExpectancy.csv")
library(dplyr)
data <- read.csv("LifeExpectancy.csv")
data <- read.csv("LifeExpectancy.csv")
setwd("C:/Users/xusef/Documents/GitableGabe/DATA_605")
data <- read.csv("LifeExpectancy.csv")
head(data)
summary(data)
data <- read.csv("LifeExpectancy.csv", header = TRUE)
head(data)
summary(data)
data <- read.csv("LifeExpectancy.csv", skip = 1, header = TRUE)
head(data)
summary(data)
header1 <- read.csv("LifeExpectancy.csv", header = FALSE, nrows = 1)
lifeExpect_df <- read.csv("LifeExpectancy.csv", skip = 1, header = TRUE)
# Combine the two headers
colnames(lifeExpect_df) <- paste(trimws(header1), trimws(names(lifeExpect_df)), sep = "_")
# View the first few rows to confirm the headers
head(lifeExpect_df)
header1 <- read.csv("LifeExpectancy.csv", header = FALSE, nrows = 1, stringsAsFactors = FALSE)
header1[is.na(header1)] <- ""
df1 <- read.csv("LifeExpectancy.csv", skip = 1, header = TRUE, stringsAsFactors = FALSE)
colnames(df1) <- paste(trimws(header1), trimws(names(df1)), sep = "_")
colnames(df1) <- gsub("_$", "", colnames(df1)) # Remove trailing underscores
colnames(df1) <- gsub("^_", "", colnames(df1)) # Remove leading underscores
# View the first few rows to confirm the headers
head(df1)
# Read the data without headers to keep both rows as data
data <- read.csv("LifeExpectancy.csv", header = FALSE)
# Extract the two header rows and merge them
header_row1 <- as.character(data[1, ])
header_row2 <- as.character(data[2, ])
merged_headers <- paste(header_row1, header_row2, sep = "_")
# Remove any leading or trailing white spaces
merged_headers <- trimws(merged_headers)
# Remove the first two rows (header rows) from the dataset
data <- data[-c(1, 2), ]
# Set the merged headers as column names
colnames(data) <- merged_headers
# Convert the data to appropriate types
data <- type.convert(data, as.is = TRUE)
# View the first few rows to confirm the headers are correctly set
head(data)
# Read the data without headers to keep both rows as data
data <- read.csv("LifeExpectancy.csv", header = FALSE)
# Extract the two header rows and merge them
header_row1 <- as.character(data[1, ])
header_row2 <- as.character(data[2, ])
merged_headers <- paste(header_row1, header_row2, sep = "_")
# Remove any underscores, then trim leading or trailing spaces
merged_headers <- gsub("_", " ", merged_headers) # Replace underscores with spaces
merged_headers <- trimws(merged_headers)         # Trim spaces
# Remove the first two rows (header rows) from the dataset
data <- data[-c(1, 2), ]
# Set the cleaned merged headers as column names
colnames(data) <- merged_headers
# Convert the data to appropriate types
data <- type.convert(data, as.is = TRUE)
# View the first few rows to confirm the headers are correctly set
head(data)
library(dplyr)
df1 <- read.csv("LifeExpectancy.csv", header = FALSE)
header_row1 <- as.character(df1[1, ])
header_row2 <- as.character(df1[2, ])
merged_headers <- paste(header_row1, header_row2, sep = "_")
merged_headers <- gsub("_", " ", merged_headers) # Replace underscores with spaces
merged_headers <- trimws(merged_headers)         # Trim spaces
df1 <- df1[-c(1, 2), ]
colnames(df1) <- merged_headers
df1 <- type.convert(df1, as.is = TRUE)
head(df1)
summary(df1)
# Convert categorical variables to factors if needed
df1$`Countries, territories and areas` <- as.factor(df1$`Countries, territories and areas`)
df1$Year <- as.numeric(df1$Year)  # Ensure 'Year' is numeric for regression
# Define the regression model
model <- lm(`Life expectancy at birth (years) Both sexes` ~ `Healthy life expectancy (HALE) at age 60 (years) Female` + Year, data = df1)
# Summarize the model to view results
summary(model)
coef(model)
plot(model$residuals)
summary(model)$r.squared
# Convert categorical variables to factors if needed
df1$`Countries, territories and areas` <- as.factor(df1$`Countries, territories and areas`)
df1$Year <- as.numeric(df1$Year)  # Ensure 'Year' is numeric for regression
# Define the regression model
model <- lm(`Life expectancy at birth (years) Both sexes` ~ df1$`Life expectancy at birth (years) Female` + Year, data = df1)
# Summarize the model to view results
summary(model)
names(df1)
# Convert categorical variables to factors if needed
df1$`Countries, territories and areas` <- as.factor(df1$`Countries, territories and areas`)
df1$Year <- as.numeric(df1$Year)  # Ensure 'Year' is numeric for regression
# Define the regression model
model <- lm(`Life expectancy at birth (years) Both sexes` ~ df1$`Life expectancy at birth (years) Female` + Year, data = df1)
# Summarize the model to view results
summary(model)
coef(model)
plot(model$residuals)
summary(model)$r.squared
