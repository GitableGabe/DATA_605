library("jpeg")
library("Matrix")
library("pracma")
library("png")
library("reshape2")
a<-matrix(c(3,1,2,0,5,4,0,0,2), nrow = 3, byrow = TRUE)
print(a)
eigen_A<-eigen(A)
A_diag<-P %*% D %*% P_inv
library("gganimate")
library("ggplot2")
library("gridExtra")
library("imager")
library("jpeg")
library("Matrix")
library("pracma")
library("png")
library("reshape2")
a<-matrix(c(3,1,2,0,5,4,0,0,2), nrow = 3, byrow = TRUE)
print(a)
eigen_A<-eigen(A)
library("gganimate")
library("ggplot2")
library("gridExtra")
library("imager")
library("jpeg")
library("Matrix")
library("pracma")
library("png")
library("reshape2")
A<-matrix(c(3,1,2,0,5,4,0,0,2), nrow = 3, byrow = TRUE)
print(a)
eigen_A<-eigen(A)
P<-eigen_A$vectors
D<-eigen_A$values
P_inv<-solve(P)
A_diag<-P %*% D %*% P_inv
A_diag <- P %*% D %*% P_inv
library("gganimate")
library("ggplot2")
library("gridExtra")
library("imager")
library("jpeg")
library("Matrix")
library("pracma")
library("png")
library("reshape2")
A<-matrix(c(3,1,2,0,5,4,0,0,2), nrow = 3, byrow = TRUE)
print(a)
eigen_A<-eigen(A)
P<-eigen_A$vectors
D<-diag(eigen_A$values)
P_inv<-solve(P)
A_diag <- P %*% D %*% P_inv
print(A_diag)
library("gganimate")
library("ggplot2")
library("gridExtra")
library("imager")
library("jpeg")
library("Matrix")
library("png")
library("pracma")
library("reshape2")
# construct square
square <- matrix(c(0, 0,
1, 0,
1, 1,
0, 1,
0, 0),
ncol = 2, byrow = TRUE)
# Make into a data frame for further use
square_df <- data.frame(x = square[,1], y = square[,2])
# Select factor to scale by
scale_factor<- 4
# copy the original square data frame
square_scaled_df <- square_df
# scale the x value
square_scaled_df$x <- square_df$x*scale_factor
# scale the y value
square_scaled_df$y <- square_df$y*scale_factor
# in order to rotate by multiplying x and y by cosine and sine of the rotation
# angle
# obtain rotation angle (45 degree)
theta <- pi/4
# copy the original square data frame
square_rotate_df <- square_scaled_df
# rotate x
square_rotate_df$x <- square_scaled_df$x * cos(theta) - square_scaled_df$y * sin(theta)
# rotate y
square_rotate_df$y <- square_scaled_df$x * sin(theta) + square_scaled_df$y * cos(theta)
# reflect by flipping coordinates, in this case x
square_reflected_df <- square_df
square_reflected_df$x <- -square_df$x
# Make the square
ani_square <- matrix(c(0, 0,
1, 0,
1, 1,
0, 1,
0, 0),
ncol = 2, byrow = TRUE)
# Make square a data frame
ani_square_df <- data.frame(x = ani_square[,1], y = ani_square[,2])
# Make a sequence of scale factors and angles
ani_scale_factors <- seq(1, 2, length.out = 50)  # Scaling from 1 to 2
ani_angles <- seq(0, pi/2, length.out = 50)  # Rotate from 0 to 90 degrees
# Empty data frame for storing transformation
ani_transformed_frames <- data.frame()
# For Loop to increment through
for (i in 1:length(ani_scale_factors)) {
# Scale and rotating variables
ani_scale_factor <- ani_scale_factors[i]
ani_angle <- ani_angles[i]
# animated scale frames
ani_scaling_matrix <- matrix(c(ani_scale_factor, 0,
0, ani_scale_factor),
nrow = 2)
# animated rotation
ani_rotation_matrix <- matrix(c(cos(ani_angle), -sin(ani_angle),
sin(ani_angle), cos(ani_angle)),
nrow = 2)
# Use %*% for combining
ani_transformation_matrix <- ani_scaling_matrix %*% ani_rotation_matrix
# Add the transformation to square
ani_transformed_square <- as.matrix(ani_square_df) %*% t(ani_transformation_matrix)
# Add dataframe to step
ani_transformed_df <- data.frame(x = ani_transformed_square[,1], y = ani_transformed_square[,2])
ani_transformed_df$step <- i  # Step number for animation
ani_transformed_frames <- rbind(ani_transformed_frames, ani_transformed_df)
}
ggplot(square_df, aes(x = x, y = y)) +
geom_polygon(fill = "lightgreen", color = "darkgreen") +
coord_fixed() + ggtitle("Square")
ggplot(square_scaled_df, aes(x = x, y = y)) +
geom_polygon(fill = "lightgreen", color = "darkgreen") +
coord_fixed() + ggtitle("Scaled Square")
ggplot(square_rotate_df, aes(x = x, y = y)) +
geom_polygon(fill = "lightgreen", color = "darkgreen") +
coord_fixed() + ggtitle("Rotated Square")
ggplot(square_reflected_df, aes(x = x, y = y)) +
geom_polygon(fill = "lightgreen", color = "darkgreen") +
coord_fixed() + ggtitle("Reflected Square")
animate(ggplot(ani_transformed_frames, aes(x = x, y = y, group = step)) +
geom_polygon(fill = NA, color = "darkgreen") +
coord_fixed() +
transition_states(step, transition_length = 2, state_length = 1) +
labs(title = 'Step {closest_state}') +
ease_aes('linear'))
rm(list = ls(pattern = "^(ani|i|square)"))
img <- load.image("GrayScaleIMG.jpg")
gray <- grayscale(img)
gray_matrix <- as.matrix(gray)
# Print the dimensions to confirm it's a matrix
print(dim(gray_matrix))
plot(gray, main = "Grayscale Image")
gray_svd <- svd(gray_matrix)
gray_U<- gray_svd$u
gray_Sigma<- gray_svd$d
gray_Vt<- t(gray_svd$v)
gray_reconstruct <- function(U,Sigma,Vt,k){
U_k <- U[,1:k]
Sigma_k <- diag(Sigma[1:k])
Vt_k <- Vt[,1:k]
img_reconstructed <- U_k %*% Sigma_k %*% t(Vt_k)
return(img_reconstructed)
}
# gray_reconstruct(gray_U, gray_Sigma, gray_Vt, k)
k_values <- c(5, 20, 50)  # Values of k for compression
# Set up plotting area
par(mfrow = c(1, length(k_values) + 1)) # Arrange plots
# Visualize the original image
image(gray_matrix, col=gray.colors(256),  main = "Original Image", axes = FALSE)
# Visualize reconstructed images for different k values
for (k in k_values) {
img_reconstructed <- gray_reconstruct(gray_U, gray_Sigma, gray_Vt, k)
# Ensure the image matrix is properly scaled and in the correct range
img_reconstructed <- pmax(pmin(img_reconstructed, 1), 0)  # Clip values to [0, 1] range
# Plot the reconstructed image
image(img_reconstructed, col=gray.colors(256), main = paste("Reconstructed k =", k), axes = FALSE)
}
rm(list = ls())
rank_matrix <- matrix(c(1, 4, 1, 3, -2, -3, 4, 1, 5, 6, 2, 8, -1, -2, 3, 7), nrow = 4, byrow = TRUE)
print(rank_matrix)
rank_matrix_echelon<-rref(rank_matrix)
print(rank_matrix_echelon)
qr(rank_matrix)[2]
Proof_Matrix <- matrix(c(1, 2, 3, 4, 2, 4, 6, 8, 3, 6, 9, 12), nrow = 3, ncol = 4, byrow = TRUE)
Proof_Matrix
Proof_rank <- qr(Proof_Matrix)$rank
Proof_rank
# Find row space (basis of row vectors) using singular value decomposition (SVD)
svd_A <- svd(Proof_Matrix)
row_space_basis <- svd_A$u[, 1:Proof_rank]
print("Row space basis vectors:")
print(row_space_basis)
# Find column space (basis of column vectors)
column_space_basis <- svd_A$v[, 1:Proof_rank]
print("Column space basis vectors:")
print(column_space_basis)
B<-matrix(c(2, 5, 7, 4, 10, 14, 1, 2.5, 3.5), nrow = 3, byrow = TRUE)
B_rank<-qr(B)$rank
print(B_rank)
rref_B<-rref(B)
print(rref_B)
A<-matrix(c(3,1,2,0,5,4,0,0,2), nrow = 3, byrow = TRUE)
print(A)
Eigen_matrix<-eigen(A)$vector
print(Eigen_matrix)
det_Eigen_matrix <-det(Eigen_matrix)
cat("Determinant of the matrix of eigenvectors:\n")
print(det_Eigen_matrix)
# Check if the eigenvectors are linearly independent
if (det_Eigen_matrix != 0) {
cat("The eigenvectors are linearly independent.\n")
} else {
cat("The eigenvectors are NOT linearly independent.\n")
}
library("gganimate")
library("ggplot2")
library("gridExtra")
library("imager")
library("jpeg")
library("Matrix")
library("png")
library("pracma")
library("reshape2")
# construct square
square <- matrix(c(0, 0,
1, 0,
1, 1,
0, 1,
0, 0),
ncol = 2, byrow = TRUE)
# Make into a data frame for further use
square_df <- data.frame(x = square[,1], y = square[,2])
# Select factor to scale by
scale_factor<- 4
# copy the original square data frame
square_scaled_df <- square_df
# scale the x value
square_scaled_df$x <- square_df$x*scale_factor
# scale the y value
square_scaled_df$y <- square_df$y*scale_factor
# in order to rotate by multiplying x and y by cosine and sine of the rotation
# angle
# obtain rotation angle (45 degree)
theta <- pi/4
# copy the original square data frame
square_rotate_df <- square_scaled_df
# rotate x
square_rotate_df$x <- square_scaled_df$x * cos(theta) - square_scaled_df$y * sin(theta)
# rotate y
square_rotate_df$y <- square_scaled_df$x * sin(theta) + square_scaled_df$y * cos(theta)
# reflect by flipping coordinates, in this case x
square_reflected_df <- square_df
square_reflected_df$x <- -square_df$x
# Make the square
ani_square <- matrix(c(0, 0,
1, 0,
1, 1,
0, 1,
0, 0),
ncol = 2, byrow = TRUE)
# Make square a data frame
ani_square_df <- data.frame(x = ani_square[,1], y = ani_square[,2])
# Make a sequence of scale factors and angles
ani_scale_factors <- seq(1, 2, length.out = 50)  # Scaling from 1 to 2
ani_angles <- seq(0, pi/2, length.out = 50)  # Rotate from 0 to 90 degrees
# Empty data frame for storing transformation
ani_transformed_frames <- data.frame()
# For Loop to increment through
for (i in 1:length(ani_scale_factors)) {
# Scale and rotating variables
ani_scale_factor <- ani_scale_factors[i]
ani_angle <- ani_angles[i]
# animated scale frames
ani_scaling_matrix <- matrix(c(ani_scale_factor, 0,
0, ani_scale_factor),
nrow = 2)
# animated rotation
ani_rotation_matrix <- matrix(c(cos(ani_angle), -sin(ani_angle),
sin(ani_angle), cos(ani_angle)),
nrow = 2)
# Use %*% for combining
ani_transformation_matrix <- ani_scaling_matrix %*% ani_rotation_matrix
# Add the transformation to square
ani_transformed_square <- as.matrix(ani_square_df) %*% t(ani_transformation_matrix)
# Add dataframe to step
ani_transformed_df <- data.frame(x = ani_transformed_square[,1], y = ani_transformed_square[,2])
ani_transformed_df$step <- i  # Step number for animation
ani_transformed_frames <- rbind(ani_transformed_frames, ani_transformed_df)
}
ggplot(square_df, aes(x = x, y = y)) +
geom_polygon(fill = "lightgreen", color = "darkgreen") +
coord_fixed() + ggtitle("Square")
ggplot(square_scaled_df, aes(x = x, y = y)) +
geom_polygon(fill = "lightgreen", color = "darkgreen") +
coord_fixed() + ggtitle("Scaled Square")
ggplot(square_rotate_df, aes(x = x, y = y)) +
geom_polygon(fill = "lightgreen", color = "darkgreen") +
coord_fixed() + ggtitle("Rotated Square")
ggplot(square_reflected_df, aes(x = x, y = y)) +
geom_polygon(fill = "lightgreen", color = "darkgreen") +
coord_fixed() + ggtitle("Reflected Square")
animate(ggplot(ani_transformed_frames, aes(x = x, y = y, group = step)) +
geom_polygon(fill = NA, color = "darkgreen") +
coord_fixed() +
transition_states(step, transition_length = 2, state_length = 1) +
labs(title = 'Step {closest_state}') +
ease_aes('linear'))
rm(list = ls(pattern = "^(ani|i|square)"))
img <- load.image("GrayScaleIMG.jpg")
gray <- grayscale(img)
gray_matrix <- as.matrix(gray)
# Print the dimensions to confirm it's a matrix
print(dim(gray_matrix))
plot(gray, main = "Grayscale Image")
gray_svd <- svd(gray_matrix)
gray_U<- gray_svd$u
gray_Sigma<- gray_svd$d
gray_Vt<- t(gray_svd$v)
gray_reconstruct <- function(U,Sigma,Vt,k){
U_k <- U[,1:k]
Sigma_k <- diag(Sigma[1:k])
Vt_k <- Vt[,1:k]
img_reconstructed <- U_k %*% Sigma_k %*% t(Vt_k)
return(img_reconstructed)
}
# gray_reconstruct(gray_U, gray_Sigma, gray_Vt, k)
k_values <- c(5, 20, 50)  # Values of k for compression
# Set up plotting area
par(mfrow = c(1, length(k_values) + 1)) # Arrange plots
# Visualize the original image
image(gray_matrix, col=gray.colors(256),  main = "Original Image", axes = FALSE)
# Visualize reconstructed images for different k values
for (k in k_values) {
img_reconstructed <- gray_reconstruct(gray_U, gray_Sigma, gray_Vt, k)
# Ensure the image matrix is properly scaled and in the correct range
img_reconstructed <- pmax(pmin(img_reconstructed, 1), 0)  # Clip values to [0, 1] range
# Plot the reconstructed image
image(img_reconstructed, col=gray.colors(256), main = paste("Reconstructed k =", k), axes = FALSE)
}
rm(list = ls())
rank_matrix <- matrix(c(1, 4, 1, 3, -2, -3, 4, 1, 5, 6, 2, 8, -1, -2, 3, 7), nrow = 4, byrow = TRUE)
print(rank_matrix)
rank_matrix_echelon<-rref(rank_matrix)
print(rank_matrix_echelon)
qr(rank_matrix)[2]
Proof_Matrix <- matrix(c(1, 2, 3, 4, 2, 4, 6, 8, 3, 6, 9, 12), nrow = 3, ncol = 4, byrow = TRUE)
Proof_Matrix
Proof_rank <- qr(Proof_Matrix)$rank
Proof_rank
# Find row space (basis of row vectors) using singular value decomposition (SVD)
svd_A <- svd(Proof_Matrix)
row_space_basis <- svd_A$u[, 1:Proof_rank]
print("Row space basis vectors:")
print(row_space_basis)
# Find column space (basis of column vectors)
column_space_basis <- svd_A$v[, 1:Proof_rank]
print("Column space basis vectors:")
print(column_space_basis)
B<-matrix(c(2, 5, 7, 4, 10, 14, 1, 2.5, 3.5), nrow = 3, byrow = TRUE)
B_rank<-qr(B)$rank
print(B_rank)
rref_B<-rref(B)
print(rref_B)
A<-matrix(c(3,1,2,0,5,4,0,0,2), nrow = 3, byrow = TRUE)
print(A)
Eigen_matrix<-eigen(A)$vector
print(Eigen_matrix)
det_Eigen_matrix <-det(Eigen_matrix)
cat("Determinant of the matrix of eigenvectors:\n")
print(det_Eigen_matrix)
# Check if the eigenvectors are linearly independent
if (det_Eigen_matrix != 0) {
cat("The eigenvectors are linearly independent.\n")
} else {
cat("The eigenvectors are NOT linearly independent.\n")
}
P<-Eigen_matrix
D<-diag(eigen(A)$values)
P_inv<-solve(P)
P<-Eigen_matrix
D<-diag(eigen(A)$values)
P_inv<-solve(P)
A_diag<- P %*% D %*% P_inv
cat("Matrix P (eigenvectors):\n")
print(P)
cat("Diagonal matrix D (eigenvalues):\n")
print(D)
cat("Matrix P inverse (eigenvectors inverse):\n")
print(P_inv)
cat("Matrix A reconstructed from P, D, and P^-1:\n")
print(A_diag)
ln_50<-log(0.5)
ln_215_216<-log(215/216)
ln_50/ln_215_216
choose(13,5)
choose(13,5)+(2*choose(13,6))+choose(13,7)
target
target <- choose(13,5)+(2*choose(13,6))+choose(13,7)
target
for (n in 1:20) {
for (r in 1:n) {
if (choose(n, r) == target) {
print(paste("n =", n, "r =", r, "binomial =", choose(n, r)))
}
}
}
for (n in 1:20) {
for (r in 1:floor(n / 2)) {  # Restrict r to be at most n/2
if (choose(n, r) == target) {
print(paste("n =", n, "r =", r, "binomial =", choose(n, r)))
}
}
}
choose(15,6)
# Initialize a global counter to track the number of recursive calls
recursive_call_count <- 0
binom_mod <- function(n, j, m) {
# Increment the global counter each time this function is called
recursive_call_count <<- recursive_call_count + 1
# Print out the current computation
cat("Computing binom_mod(", n, ",", j, ",", m, ")\n")
# Base cases for the binomial coefficient
if (j == 0 || j == n) {
return(1 %% m)  # C(n, 0) and C(n, n) are always 1 mod m
}
# Recursive formula: C(n, j) = C(n-1, j-1) + C(n-1, j)
return((binom_mod(n - 1, j - 1, m) + binom_mod(n - 1, j, m)) %% m)
}
make_table <- function(n, m) {
# Reset the global counter before starting the calculation for a new table
recursive_call_count <<- 0
# Create an empty matrix
binom_table <- matrix(0, nrow = n, ncol = n)
# Double 'for' loop to fill in the binomial coefficients mod m
for (i in 0:(n-1)) {
for (j in 0:i) {
binom_table[i+1, j+1] <- binom_mod(i, j, m)
}
}
# Print the total number of recursive calls made
cat("Total recursive calls for mod", m, ":", recursive_call_count, "\n")
return(binom_table)
}
run_for_all_m <- function(max_n, max_m) {
for (m in 2:max_m) {
cat("\nBinomial coefficients mod", m, ":\n")
# Generate and print the binomial table for each m
print(make_table(max_n, m))
cat("\n")
}
}
# Run the program for m = 2 to 7 and n = 5 (use smaller n for easier observation)
run_for_all_m(5, 7)
setwd("C:/Users/xusef/Documents/GitableGabe/DATA_605")
dpois(0,n*p)
n<-10000
p<-1/1000
dpois(0,n*p)
format(dpois(0,n*p),digits=7)
prob_no_one<-dpois(0,n*p)
format(prob_no_one,digits=7)
format(prob_no_one,digits=7,scientific = FALSE)
prob_no_one<-dpois(0,n*p)
format(prob_no_one,digits=7,scientific = FALSE)
format(prob_no_one,digits=6,scientific = FALSE)
format(prob_no_one,digits=5,scientific = FALSE)
n<-10000
p<-1/1000
dpois(0,n*p)
format(dpois(0,n*p),digits=5,scientific = FALSE)
lambda <- function(n) n * p  # expected value for different n
# Function to find the minimum n such that P(at least one) > 1/2
find_min_n <- function() {
n <- 1
while (dpois(0, lambda(n)) > 0.5) {
n <- n + 1
}
return(n)
}
min_n <- find_min_n()
min_n
n<-10000
p<-1/1000
dpois(0,n*p)
format(dpois(0,n*p),digits=5,scientific = FALSE)
lambda <- function(n) n * p  # expected value for different n
# Function to find the minimum n such that P(at least one) > 1/2
find_min_n <- function() {
n <- 1
while (dpois(0, lambda(n)) > 0.5) {
n <- n + 1
}
return(n)
}
min_n <- find_min_n()
min_n
lambda <- function(n) n * p  # expected value for different n
# Function to find the minimum n such that P(at least one) > 1/2
find_min_n <- function() {
n <- 1
while (dpois(0, lambda(n)) > 0.5) {
n <- n + 1
}
return(n)
}
min_n <- find_min_n()
min_n
n_2 <- ceiling(log(0.5) / -p)
n_2
